** Load the data use samplefinal, clearlocal y="math16"local w1="math11"local ncov=ncovlocal ninst=ninstif `ncov'==1{local option="one"}else if `ncov'==2{local option="three"}if `ninst'==1{local z1="math7 read7"}else if `ninst'==2{local z1="draw copy"}else if `ninst'==3{local z1="FEDUC MEDUC"}** Nboot=nb of bootstrap iterationsmata Nboot=100mata:// Nboot=nb of bootstrap iterations// Nquant=nb of percentilesNboot=100Nquant=99// ngrid is the number of nods to compute the characteristic function (and integrate it)// npoint is the number of values where the densities/cdfs are evaluatedngrid=201npoint=1001// S is the bandwidth for the deconvolution// May be modified, using as a guide the approach in Diggle and Hall (1993)// See program Diggle.do// Here are reported the values for math16 as the dependent variableS=.42end** Keep children with non-missing parental education when the Z's used are (FEDUC,MEDUC)local FEDUClist="FEDUC MEDUC"local a : list FEDUClist==z1if `a'==1 {keep if FEDUCmiss==0 & MEDUCmiss==0local zerolist=""}else {local zerolist="FEDUC MEDUC FEDUCmiss MEDUCmiss"}** Covariates: possible choiceslocal onelist "`zerolist' cmsex sc580-sc584 sc58miss sc69* sc1965* sc65miss oldersib oldersibmiss mwork65 mwork65miss MINC1-MINC2 FINC1-FINC4" local twolist "`onelist' stay65 stay65miss nchildc65 nchildc65miss noschool noschoolmiss ptr69 ptr69miss junior69 buildage69 buildage69miss nostream69"*!RESTRICTED: APPLY FOR LOCAL LICENSE TO USE*local threelist "`twolist' usick mwork mininge manage skme sskme ppr iwc immi RE161-RE169"local threelist "`twolist' RE161-RE169"** Rule of thumb's bandwidth for smoothing cdf's and pdf's** Used for estimates on the raw data onlyqui _pctile `y', p(25 75)scalar bw=(r(r2)-r(r1))/1.34qui su `y'scalar bw=.9*min(r(sd),bw)*_N^(-1/5)mata:bw=st_numscalar("bw")end** The program allows for several W's or Z'slocal b: list sizeof w1scalar B=`b'** Keep observations with non-missing dependent/independent variables ** RESTRICTED: removed variable la from these two lists, please include if you have LICENSE ACCESSkeep ``option'list' `y' `w1' `z1' C GRAM SECMOD qui reg `y' ``option'list'  `w1' `z1' Ckeep if e(sample)** Save the initial samplesave init, replace** Start mata routinemata: // Matrices of bootstrapped estimates: ratio of beta's, mean, variance, quantilesRT=J(Nboot,3,.)MT=J(Nboot,3,.)VT=J(Nboot,3,.)MT2=J(Nboot,1,.)VT2=J(Nboot,1,.)QT=J(Nboot,Nquant,.)MGS=J(Nboot,2,.)b=st_numscalar("B")// Bootstrap iterations// The iteration (Nboot+1) is the estimate on the original samplefor (j=1;j<=Nboot+1;j++){stata("use init, clear")// Bootstrap, clustered at the LEA (and individual) levelif (j<=Nboot){//stata("bsample, cluster(la)")//Removed clustering at la levelstata("bsample")}// 2SLS regression, to estimate the ratio of beta's// C=1 denotes comprehensiveif (j<=Nboot){stata("qui ivreg2 `y' (`w1'=`z1') ``option'list' if C==1")}if (j==Nboot+1){//Removed clustering at la level//stata("ivreg2 `y' (`w1'=`z1') ``option'list' if C==1, first cluster(la)")stata("ivreg2 `y' (`w1'=`z1') ``option'list' if C==1")}stata("matrix eb=e(b)")if (b==1){	stata("scalar Ratio1=eb[1,1]")	stata("scalar Ratio2=.")	stata("qui gen w=Ratio1*`w1'")	if (j<=Nboot){	RT[j,1]=st_numscalar("Ratio1")	}}else if (b==2){stata("scalar Ratio1=eb[1,1]")stata("scalar Ratio2=eb[1,2]")// Note: this line needs to be modified when there are 2 W's, different from (math11,read11)stata("qui gen w=Ratio1*math11+Ratio2*read11")if (j<=Nboot){	RT[j,1]=st_numscalar("Ratio1")	RT[j,2]=st_numscalar("Ratio2")	}}else if (b==3){stata("scalar Ratio1=eb[1,1]")stata("scalar Ratio2=eb[1,2]")stata("scalar Ratio3=eb[1,3]")// Note: this line needs to be modified when there are 3 W's, different from (math11,read11,verbal11)stata("qui gen w=Ratio1*math11+Ratio2*read11+Ratio3*verbal11")if (j<=Nboot){	RT[j,1]=st_numscalar("Ratio1")	RT[j,2]=st_numscalar("Ratio2")	RT[j,3]=st_numscalar("Ratio3")	}}// Compute regression residualsstata("qui reg `y' ``option'list' if C==1")stata("qui predict resy1, resid")stata("qui reg `y' ``option'list' if C==0")stata("qui predict resy0, resid")stata("qui reg w ``option'list' if C==1")stata("qui predict resw1, resid")stata("qui reg w ``option'list' if C==0")stata("qui predict resw0, resid")stata("qui reg `z1' ``option'list' if C==1")stata("qui predict resz11, resid")stata("qui reg `z1' ``option'list' if C==0")stata("qui predict resz10, resid")// Propensity score stata("qui xi: logit C ``option'list' if C==0|C==1")stata("qui predict piX")stata("qui su C if C==0|C==1")stata("scalar piC=r(mean)")// Mean effect, rawstata("qui su `y' if C==0")stata("scalar mean0=r(mean)")stata("qui su `y' if C==1")stata("scalar mean1=r(mean)")mean0=st_numscalar("mean0")mean1=st_numscalar("mean1")// Mean effect, matching on observablesstata("qui gen effectm=C/(1-piC)*(`y')*(1-piX)/piX if piX>=0.05 & piX<=0.95")stata("qui su effectm if C==0|C==1")stata("scalar meanm1=r(mean)")// Mean effect, matching on observables and unobservablesstata("qui su w if C==0")stata("qui gen effect=C/(1-piC)*(`y'-w)*(1-piX)/piX+r(mean) if piX>=0.05 & piX<=0.95")stata("qui su effect if C==0|C==1")stata("scalar meanc1=r(mean)")stata("scalar dmean=mean0-mean1")stata("scalar dmeanc=mean0-meanc1")stata("scalar dmeanm=mean0-meanm1")meanc1=st_numscalar("meanc1")meanm1=st_numscalar("meanm1")if (j<=Nboot){MT[j,1]=st_numscalar("dmean")MT[j,2]=st_numscalar("dmeanc")MT[j,3]=st_numscalar("dmeanm")}// Compute regression residuals and squared residualsstata("qui reg w ``option'list'")stata("qui predict resw, resid")stata("qui gen resw1_2=(resw1)^2")stata("qui gen resw0_2=(resw0)^2")stata("qui gen resy1_2=(resy1)^2")stata("qui gen resy0_2=(resy0)^2")stata("qui gen resw_2=(resw)^2")// Generate the indicator of selective schoolingstata("g NC=(C==0)")// Transfering the data from Stata to Matastata("qui cumul `y' if C==0, gen(rank`y')")c=st_data(.,("C"))nc=st_data(.,("NC"))y=st_data(.,("`y'"))y0=st_data(.,("`y'"),"NC")y1=st_data(.,("`y'"),"C")p=st_data(.,("piX"))w=st_data(.,("w"))w1=st_data(.,("w"),"C")w0=st_data(.,("w"),"NC")ResVarY1=st_data(.,"resy1_2")ResVarY0=st_data(.,"resy0_2")ResVarW1=st_data(.,"resw1_2")ResVarW0=st_data(.,"resw0_2")ResVarW=st_data(.,"resw_2")n1=colsum(c)n=rows(y)n0=n-n1pc=(1/n)*n1// Support of the dependent variable // May be modified if neededsuppmin=min(y)-(max(y)-min(y))/5suppmax=max(y)+(max(y)-min(y))/5// Generating a constantstata("g cons=1")stata("keep ``option'list' cons C NC")X=st_data(.,.)X0=select(X,nc)X1=select(X,c)stata("drop C NC")X=st_data(.,.)// Variance, raw and matchingvarc1=(1/n1)*colsum((ResVarY1-(ResVarW1-ResVarW0)):*(J(n,1,1)-c))+variance(X0*pinv(X1)*y1+(X0*(pinv(X0)*w0-pinv(X1)*w1)))varm1=(1/n1)*colsum((ResVarY1):*(J(n,1,1)-c))+variance(X0*pinv(X1)*y1)var1=variance(y1)var0=variance(y0)v0=var0-var1v0c=var0-varc1v0m=var0-varm1if (j<=Nboot){VT[j,1]=v0VT[j,2]=v0cVT[j,3]=v0m}// Characteristic function psiY20=J(ngrid,1,0+0i)psiD=J(ngrid,1,0+0i)ti=J(npoint,1,0)tD=J(ngrid,1,0)B11=y:*J(n,1,0+1i)B0=w:*J(n,1,0+1i)pinvX=pinv(X)t=range(-S,S,(2*S)/(ngrid-1))	   expbt=exp(B0*t')	   expbt1=pinvX*((J(n,1,1)-c):*expbt)	   expbt2=pinvX*(c:*expbt)		beta1=X*(expbt1)	   	beta2=X*(expbt2)	   	psiY20=conj((1/(n*(1-pc)))*colsum(c:*(exp(B11*t')):*((beta1):/(beta2)):*(p:<=.95*J(rows(p),1,1)):*(p:>=.05*J(rows(p),1,1))))'	    psiY20=psiY20:/((1/(n))*colsum((p:<=.95*J(rows(p),1,1)):*(p:>=.05*J(rows(p),1,1))))// Rescaling the c.f. so that the distribution has mean meanc1// May be removed	     	    alpha=-log(psiY20[ngrid/2])		beta=meanc1+(1i)*(log(psiY20[ngrid/2+10])-log(psiY20[ngrid/2-10]))*(ngrid-1)/(40*S)	      		psiY20=psiY20:*exp(alpha*J(rows(t),1,1)+(1i)*beta*t)// Density functionf=J(npoint,1,0+0i)for (k=1; k<=npoint; k++) {// Support of the counterfactual densityspt=suppmin+(k-1)*(suppmax-suppmin)/(npoint-1)// Inverse Fourier transformationf[k,1]=(1/(2*pi()))*colsum((psiY20):*exp(-J(ngrid,1,1i):*t:*spt))*2*(S/(ngrid-1))}// Impose that the density is non-negative, and integrates to 1// May be removedf=Re(f):*(Re(f):>0)f=f/colsum(f:*(f:>0)*(suppmax-suppmin)/(npoint-1))if (j==Nboot+1){st_matrix("D",f)}// Cumulative distribution functionff=J(npoint,1,0+0i)ff=mm_colrunsum(f:*(f:>0))*(suppmax-suppmin)/(npoint-1)for (l=1; l<=npoint; l++) {ti[l,1]= suppmin+(l-1)*(suppmax-suppmin)/(npoint-1)}if (j==Nboot+1){st_matrix("C",Re(ff))st_matrix("support",ti)}// Original CDFfo=J(npoint,1,0)for (m=1; m<=npoint; m++) {spt=suppmin+(m-1)*(suppmax-suppmin)/(npoint-1)fo[m,1]=(1/(n0))*colsum(J(n0,1,1)-normal((y0-J(n0,1,spt))/bw))}if (j==Nboot+1){st_matrix("O",fo)}// Original density, using the same bandwidthfd=J(npoint,1,0)for (n=1; n<=npoint; n++) {spt=suppmin+(n-1)*(suppmax-suppmin)/(npoint-1)fd[n,1]=(1/n0)*colsum((1/bw)*mm_kern("gaussian",(y0-J(n0,1,spt))/bw))}if (j==Nboot+1){st_matrix("A",fd)}//  Quantile effects, inverting the cdf's// Correctedsteps=range(0,1,1/(Nquant-1))fe=Re(ff)quantorig=J(Nquant,1,0)yqtilec1=J(Nquant,1,0)d=J(1,1,0)K=J(Nquant,2,0)quantorig=(fe#J(1,Nquant,1)-(steps')#J(npoint,1,1))quantorig=quantorig:*quantorigsupp=range(suppmin, suppmax,(suppmax-suppmin)/(npoint-1))for (o=1; o<=Nquant;o++){minindex(quantorig[,o],1,d,K)yqtilec1[o,]=supp[d[1]]}// Uncorrectedquantorig=J(Nquant,1,0)yqtile0=J(Nquant,1,0)d1=J(1,1,0)quantorig=(fo#J(1,Nquant,1)-(steps')#J(npoint,1,1))quantorig=quantorig:*quantorigsupp=range(suppmin, suppmax,(suppmax-suppmin)/(npoint-1))for (p=1; p<=Nquant;p++){minindex(quantorig[,p],1,d1,K)yqtile0[p,]=supp[d1[1]]}dqtile=yqtile0-yqtilec1if (j<=Nboot){QT[j,1..Nquant]=dqtile'}// Means and variances, obtained from the estimated quantilesmean02=mean(yqtile0)var02=mean(yqtile0:^2)-mean02^2meanc12=mean(yqtilec1)varc12=mean(yqtilec1:^2)-meanc12^2if (j<=Nboot){MT2[j,1]=mean02-meanc12VT2[j,1]=var02-varc12}}// END OF BOOTSTRAPst_matrix("Q",dqtile)st_matrix("V",steps)st_matrix("R",QT)end** Post-processing of output (graphs etc.)  svmat Q, names(qtdiff)svmat V, names(tau)svmat D, names(density)svmat C, names(cumultreat)svmat O, names(cumulorig)svmat A, names(origdens)svmat support, names(support)svmat R, names(quantiles)cap drop lower uppergen lower=.gen upper=.** +/- twice the bootstraped standard errors local obs=1forvalues i=1(1)99{qui su quantiles`i'replace lower=qtdiff1-2*r(sd) in `obs'replace upper=qtdiff1+2*r(sd) in `obs'local obs=`obs'+1}keep if _n<=99if `ncov'==1 & `ninst'==1{mkmat tau1, matrix(tau)}mkmat qtdiff1, matrix(qtdiff)mkmat lower, matrix(lower)mkmat upper, matrix(upper)use figure1, clearif `ncov'==1 & `ninst'==1{svmat tauqui replace tau=tau1}svmat qtdiffsvmat lowersvmat upperqui replace est`ncov'`ninst'=qtdiff1qui replace low`ncov'`ninst'=lower1qui replace up`ncov'`ninst'=upper1drop qtdiff1 lower1 upper1if `ncov'==1 & `ninst'==1{drop tau1}save figure1, replace
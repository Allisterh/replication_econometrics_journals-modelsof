** Load the data set more offuse samplefinal, clearlocal y="math16"local w1="math11"local ncov=ncovlocal ninst=ninstif `ncov'==1{local option="one"}else if `ncov'==2{local option="two"}else if `ncov'==3{local option="three"}else if `ncov'==4{local option="five"}else if `ncov'==5{local option="six"}if `ninst'==1{local z1="math7 read7"}else if `ninst'==2{local z1="draw copy"}else if `ninst'==3{local z1="FEDUC MEDUC"}mata:// Nboot=nb of bootstrap iterations// Nquant=nb of percentilesNboot=100Nquant=99// ngrid is the number of nods to compute the characteristic function (and integrate it)// npoint is the number of values where the densities/cdfs are evaluatedngrid=201npoint=1001// S is the bandwidth for the deconvolution// May be modified, using as a guide the approach in Diggle and Hall (1993)// See program Diggle.doS=.42end** Keep children with non-missing parental education when the Z's used are (FEDUC,MEDUC)local FEDUClist="FEDUC MEDUC"local aa : list FEDUClist==z1if `aa'==1 {keep if FEDUCmiss==0 & MEDUCmiss==0local zerolist=""}else {local zerolist="FEDUC MEDUC FEDUCmiss MEDUCmiss"}** Covariates: seven possible choiceslocal onelist "`zerolist' cmsex sc580-sc584 sc58miss sc69* sc1965* sc65miss oldersib oldersibmiss mwork65 mwork65miss MINC1-MINC2 FINC1-FINC4" local twolist "`onelist' stay65 stay65miss nchildc65 nchildc65miss noschool noschoolmiss ptr69 ptr69miss junior69 buildage69 buildage69miss nostream69"local threelist "`twolist' RE161-RE169"*!RESTRICTED: only available with special license*local fourlist "`threelist' lab_cont pop_size pop_dens indus"local fivelist "`threelist'"** Sixlist is a list of interacted covariateslocal a: list sixlist==`option'listif `a'==1{if `aa'==0{local sixlist "cmsex FEDUC sc580-sc584 nchildc65 junior69 buildage69 nostream69 RE161-RE169"foreach vv of varlist `sixlist'{foreach ww of varlist `sixlist'{gen `vv'`ww'=`vv'*`ww'}}local sixlist "cmsex* FEDUC* sc58* nchildc65* junior69* buildage69* nostream69* RE161*"#delimit ;local sixlist "`sixlist' sc69* sc58miss sc1965* sc65miss oldersib oldersibmiss mwork65 mwork65miss MINC1-MINC2 FINC1-FINC4 stay65 stay65miss nchildc65miss noschool noschoolmiss ptr69 ptr69miss  buildage69miss";#delimit crqui drop cmsexcmsex cmsexFEDUC cmsexnchildc65 FEDUCsc581 FEDUCsc582 FEDUCbuildage69 FEDUCnostream69 FEDUCRE161 qui drop sc580cmsex sc580FEDUC sc580sc580 sc580sc581 sc580sc582 sc580sc583 sc580sc584 qui drop sc580nchildc65 sc580nostream69 sc581cmsex sc581sc580 sc581sc581 sc581sc582 qui drop sc581sc583 sc581sc584 sc582cmsex sc582sc580 sc582sc581 sc582sc582 qui drop sc582sc583 sc582sc584 sc582nostream69 sc583cmsex sc583FEDUC sc583sc580 sc583sc581 qui drop sc583sc582 sc583sc583 sc583sc584 sc584cmsex sc584FEDUC sc584sc580 qui drop sc584sc581 sc584sc582 sc584sc583 sc584sc584 sc584RE161 nchildc65FEDUC qui drop nchildc65sc581 nchildc65sc582 nchildc65sc583 nchildc65sc584 qui drop nchildc65junior69 junior69cmsex junior69FEDUC junior69sc580 junior69sc581 qui drop junior69sc582 junior69sc583 junior69sc584 junior69junior69 buildage69cmsex qui drop buildage69sc580 buildage69sc581 buildage69sc582 buildage69sc583 buildage69sc584 qui drop buildage69nchildc65 buildage69junior69 nostream69cmsex nostream69sc581 nostream69sc583 nostream69sc584 nostream69nchildc65 qui drop nostream69junior69 nostream69buildage69 nostream69nostream69qui drop RE161 RE161cmsex RE161sc58* RE161nchildc65 RE161junior69 RE161buildage69 RE161nostream69 RE161RE* }else if `aa'==1{local sixlist "cmsex sc580-sc584 nchildc65 junior69 buildage69 nostream69 RE161-RE169"foreach vv of varlist `sixlist'{foreach ww of varlist `sixlist'{gen `vv'`ww'=`vv'*`ww'}}local sixlist "cmsex* sc58* nchildc65* junior69* buildage69* nostream69* RE161*"#delimit ;local sixlist "`sixlist' sc69* sc58miss sc1965* sc65miss oldersib oldersibmiss mwork65 mwork65miss MINC1-MINC2 FINC1-FINC4 stay65 stay65miss nchildc65miss noschool noschoolmiss ptr69 ptr69miss  buildage69miss";#delimit crqui drop cmsexcmsex cmsexnchildc65  qui drop sc580cmsex  sc580sc580 sc580sc581 sc580sc582 sc580sc583 sc580sc584 drop sc580nchildc65 sc580nostream69 sc581cmsex sc581sc580 sc581sc581 sc581sc582 qui drop sc581sc583 sc581sc584 sc582cmsex sc582sc580 sc582sc581 sc582sc582 qui drop sc582sc583 sc582sc584 sc582nostream69 sc583cmsex  sc583sc580 sc583sc581 qui drop sc583sc582 sc583sc583 sc583sc584 sc584cmsex  sc584sc580 qui drop sc584sc581 sc584sc582 sc584sc583 sc584sc584 sc584RE161  qui drop nchildc65sc581 nchildc65sc582 nchildc65sc583 nchildc65sc584 qui drop nchildc65junior69 junior69cmsex  junior69sc580 junior69sc581 qui drop junior69sc582 junior69sc583 junior69sc584 junior69junior69 buildage69cmsex qui drop buildage69sc580 buildage69sc581 buildage69sc582 buildage69sc583 buildage69sc584 qui drop buildage69nchildc65 buildage69junior69 nostream69cmsex nostream69sc581 nostream69sc583 nostream69sc584 nostream69nchildc65 qui drop nostream69junior69 nostream69buildage69 nostream69nostream69qui drop RE161 RE161cmsex RE161sc58* RE161nchildc65 RE161junior69 RE161buildage69 RE161nostream69 RE162RE* }}gen init`y'=`y'** Rule of thumb's bandwidth for smoothing cdf's and pdf's** Used for estimates on the raw data onlyqui _pctile `y', p(25 75)scalar bw=(r(r2)-r(r1))/1.34qui su `y'scalar bw=.9*min(r(sd),bw)*_N^(-1/5)mata:bw=st_numscalar("bw")end** The program allows for several W's or Z'slocal b: list sizeof w1scalar B=`b'** Keep observations with non-missing dependent/independent variables keep ``option'list' `y' `w1' `z1' C GRAM SECMOD init`y'qui reg `y' ``option'list'  `w1' `z1' Ckeep if e(sample)** Save the initial samplesave init2, replace** Start mata routinemata: // Matrices of bootstrapped estimates: ratio of beta's, mean, variance, quantilesRT=J(Nboot,3,.)MT=J(Nboot,3,.)VT=J(Nboot,3,.)MT2=J(Nboot,1,.)VT2=J(Nboot,1,.)QT=J(Nboot,Nquant,.)MGS=J(Nboot,2,.)b=st_numscalar("B")// Bootstrap iterations// The iteration (Nboot+1) is the estimate on the original samplefor (j=1;j<=Nboot+1;j++){stata("use init2, clear")// Bootstrap, clustered at the LEA (and individual) levelif (j<=Nboot){stata("bsample")}// 2SLS regression, to estimate the ratio of beta's// C=1 denotes comprehensiveif (j<=Nboot){stata("qui ivreg2 `y' (`w1'=`z1') ``option'list' if C==1")}if (j==Nboot+1){stata("ivreg2 `y' (`w1'=`z1') ``option'list' if C==1")}stata("matrix eb=e(b)")if (b==1){	stata("scalar Ratio1=eb[1,1]")	stata("scalar Ratio2=.")	stata("qui gen w=Ratio1*`w1'")	if (j<=Nboot){	RT[j,1]=st_numscalar("Ratio1")	}}else if (b==2){stata("scalar Ratio1=eb[1,1]")stata("scalar Ratio2=eb[1,2]")// Note: this line needs to be modified when there are 2 W's, different from (math11,read11)stata("qui gen w=Ratio1*math11+Ratio2*read11")if (j<=Nboot){	RT[j,1]=st_numscalar("Ratio1")	RT[j,2]=st_numscalar("Ratio2")	}}else if (b==3){stata("scalar Ratio1=eb[1,1]")stata("scalar Ratio2=eb[1,2]")stata("scalar Ratio3=eb[1,3]")// Note: this line needs to be modified when there are 3 W's, different from (math11,read11,verbal11)stata("qui gen w=Ratio1*math11+Ratio2*read11+Ratio3*verbal11")if (j<=Nboot){	RT[j,1]=st_numscalar("Ratio1")	RT[j,2]=st_numscalar("Ratio2")	RT[j,3]=st_numscalar("Ratio3")	}}// Compute regression residualsstata("qui reg `y' ``option'list' if C==1")stata("qui predict resy1, resid")stata("qui reg `y' ``option'list' if C==0")stata("qui predict resy0, resid")stata("qui reg w ``option'list' if C==1")stata("qui predict resw1, resid")stata("qui reg w ``option'list' if C==0")stata("qui predict resw0, resid")stata("qui reg `z1' ``option'list' if C==1")stata("qui predict resz11, resid")stata("qui reg `z1' ``option'list' if C==0")stata("qui predict resz10, resid")// Propensity score stata("qui xi: logit C ``option'list' if C==0|C==1")stata("qui predict piX")stata("qui su C if C==0|C==1")stata("scalar piC=r(mean)")// Mean effect, rawstata("qui su `y' if C==0")stata("scalar mean0=r(mean)")stata("qui su `y' if C==1")stata("scalar mean1=r(mean)")mean0=st_numscalar("mean0")mean1=st_numscalar("mean1")// Mean effect, matching on observablesstata("qui gen effectm=C/(1-piC)*(`y')*(1-piX)/piX if piX>=0.05 & piX<=0.95")stata("qui su effectm if C==0|C==1")stata("scalar meanm1=r(mean)")// Mean effect, matching on observables and unobservablesstata("qui su w if C==0")stata("qui gen effect=C/(1-piC)*(`y'-w)*(1-piX)/piX+r(mean) if piX>=0.05 & piX<=0.95")stata("qui su effect if C==0|C==1")stata("scalar meanc1=r(mean)")stata("scalar dmean=mean0-mean1")stata("scalar dmeanc=mean0-meanc1")stata("scalar dmeanm=mean0-meanm1")meanc1=st_numscalar("meanc1")meanm1=st_numscalar("meanm1")if (j<=Nboot){MT[j,1]=st_numscalar("dmean")MT[j,2]=st_numscalar("dmeanc")MT[j,3]=st_numscalar("dmeanm")}// Compute regression residuals and squared residualsstata("qui reg w ``option'list'")stata("qui predict resw, resid")stata("qui gen resw1_2=(resw1)^2")stata("qui gen resw0_2=(resw0)^2")stata("qui gen resy1_2=(resy1)^2")stata("qui gen resy0_2=(resy0)^2")stata("qui gen resw_2=(resw)^2")// Generate the indicator of selective schoolingstata("g NC=(C==0)")// Transfering the data from Stata to Matastata("qui cumul `y' if C==0, gen(rank`y')")c=st_data(.,("C"))nc=st_data(.,("NC"))y=st_data(.,("`y'"))y0=st_data(.,("`y'"),"NC")y1=st_data(.,("`y'"),"C")yg=st_data(.,("init`y'"),"GRAM")ys=st_data(.,("init`y'"),"SECMOD")rankyg=st_data(.,("rank`y'"),"GRAM")rankys=st_data(.,("rank`y'"),"SECMOD")p=st_data(.,("piX"))w=st_data(.,("w"))w1=st_data(.,("w"),"C")w0=st_data(.,("w"),"NC")ResVarY1=st_data(.,"resy1_2")ResVarY0=st_data(.,"resy0_2")ResVarW1=st_data(.,"resw1_2")ResVarW0=st_data(.,"resw0_2")ResVarW=st_data(.,"resw_2")n1=colsum(c)n=rows(y)n0=n-n1pc=(1/n)*n1// Support of the dependent variable // May be modified if neededsuppmin=min(y)-(max(y)-min(y))/5suppmax=max(y)+(max(y)-min(y))/5// Generating a constantstata("g cons=1")stata("keep ``option'list' cons C NC")X=st_data(.,.)X0=select(X,nc)X1=select(X,c)stata("drop C NC")X=st_data(.,.)// Variance, raw and matchingvarc1=(1/n1)*colsum((ResVarY1-(ResVarW1-ResVarW0)):*(J(n,1,1)-c))+variance(X0*pinv(X1)*y1+(X0*(pinv(X0)*w0-pinv(X1)*w1)))varm1=(1/n1)*colsum((ResVarY1):*(J(n,1,1)-c))+variance(X0*pinv(X1)*y1)var1=variance(y1)var0=variance(y0)v0=var0-var1v0c=var0-varc1v0m=var0-varm1if (j<=Nboot){VT[j,1]=v0VT[j,2]=v0cVT[j,3]=v0m}// Characteristic function psiY20=J(ngrid,1,0+0i)psiD=J(ngrid,1,0+0i)ti=J(npoint,1,0)tD=J(ngrid,1,0)B11=y:*J(n,1,0+1i)B0=w:*J(n,1,0+1i)pinvX=pinv(X)t=range(-S,S,(2*S)/(ngrid-1))	   expbt=exp(B0*t')	   expbt1=pinvX*((J(n,1,1)-c):*expbt)	   expbt2=pinvX*(c:*expbt)		beta1=X*(expbt1)	   	beta2=X*(expbt2)	   	psiY20=conj((1/(n*(1-pc)))*colsum(c:*(exp(B11*t')):*((beta1):/(beta2)):*(p:<=.95*J(rows(p),1,1)):*(p:>=.05*J(rows(p),1,1))))'	      psiY20=psiY20:/((1/(n))*colsum((p:<=.95*J(rows(p),1,1)):*(p:>=.05*J(rows(p),1,1))))// Rescaling the c.f. so that the distribution has mean meanc1// May be removed	     	      alpha=-log(psiY20[ngrid/2])		beta=meanc1+(1i)*(log(psiY20[ngrid/2+10])-log(psiY20[ngrid/2-10]))*(ngrid-1)/(40*S)	      		psiY20=psiY20:*exp(alpha*J(rows(t),1,1)+(1i)*beta*t)// Density functionf=J(npoint,1,0+0i)for (k=1; k<=npoint; k++) {// Support of the counterfactual densityspt=suppmin+(k-1)*(suppmax-suppmin)/(npoint-1)// Inverse Fourier transformationf[k,1]=(1/(2*pi()))*colsum((psiY20):*exp(-J(ngrid,1,1i):*t:*spt))*2*(S/(ngrid-1))}// Impose that the density is non-negative, and integrates to 1// May be removedf=Re(f):*(Re(f):>0)f=f/colsum(f:*(f:>0)*(suppmax-suppmin)/(npoint-1))if (j==Nboot+1){st_matrix("D",f)}// Cumulative distribution functionff=J(npoint,1,0+0i)ff=mm_colrunsum(f:*(f:>0))*(suppmax-suppmin)/(npoint-1)for (l=1; l<=npoint; l++) {ti[l,1]= suppmin+(l-1)*(suppmax-suppmin)/(npoint-1)}if (j==Nboot+1){st_matrix("C",Re(ff))st_matrix("support",ti)}// Original CDFfo=J(npoint,1,0)for (m=1; m<=npoint; m++) {spt=suppmin+(m-1)*(suppmax-suppmin)/(npoint-1)fo[m,1]=(1/(n0))*colsum(J(n0,1,1)-normal((y0-J(n0,1,spt))/bw))}if (j==Nboot+1){st_matrix("O",fo)}// Original density, using the same bandwidthfd=J(npoint,1,0)for (n=1; n<=npoint; n++) {spt=suppmin+(n-1)*(suppmax-suppmin)/(npoint-1)fd[n,1]=(1/n0)*colsum((1/bw)*mm_kern("gaussian",(y0-J(n0,1,spt))/bw))}if (j==Nboot+1){st_matrix("A",fd)}//  Quantile effects, inverting the cdf's// Correctedsteps=range(0,1,1/(Nquant-1))fe=Re(ff)quantorig=J(Nquant,1,0)yqtilec1=J(Nquant,1,0)d=J(1,1,0)K=J(Nquant,2,0)quantorig=(fe#J(1,Nquant,1)-(steps')#J(npoint,1,1))quantorig=quantorig:*quantorigsupp=range(suppmin, suppmax,(suppmax-suppmin)/(npoint-1))for (o=1; o<=Nquant;o++){minindex(quantorig[,o],1,d,K)yqtilec1[o,]=supp[d[1]]}// Uncorrectedquantorig=J(Nquant,1,0)yqtile0=J(Nquant,1,0)d1=J(1,1,0)quantorig=(fo#J(1,Nquant,1)-(steps')#J(npoint,1,1))quantorig=quantorig:*quantorigsupp=range(suppmin, suppmax,(suppmax-suppmin)/(npoint-1))for (p=1; p<=Nquant;p++){minindex(quantorig[,p],1,d1,K)yqtile0[p,]=supp[d1[1]]}dqtile=yqtile0-yqtilec1if (j<=Nboot){QT[j,1..Nquant]=dqtile'}// Comparisons with Grammar and Secondary Modern schoolsvecg=yg-yqtilec1[(trunc((rankyg-.001*J(rows(rankyg),1,1))*Nquant)+J(rows(rankyg),1,1)),1]dmeanG=mean(vecg:*(yg:>=2*J(rows(yg),1,1)):*(yg:<=28*J(rows(yg),1,1)))vecs=ys-yqtilec1[(trunc((rankys-.001*J(rows(rankys),1,1))*Nquant)+J(rows(rankys),1,1)),1]dmeanS=mean(vecs:*(ys:>=2*J(rows(ys),1,1)):*(ys:<=28*J(rows(ys),1,1)))if (j<=Nboot){MGS[j,1]=dmeanGMGS[j,2]=dmeanS}}// END OF BOOTSTRAPst_matrix("Q",dqtile)st_matrix("V",steps)st_matrix("R",QT)endmata:st_matrix("ebtot",MGS)st_matrix("ebG",dmeanG)st_matrix("ebS",dmeanS)endsvmat ebtot, names(std)qui su std1scalar stdG=r(sd)qui su std2scalar stdS=r(sd)use table4, clearreplace cov`ncov'=ebG[1,1] if _n==`ninst'replace cov`ncov'std=stdG if _n==`ninst'replace cov`ncov'=ebS[1,1] if _n==3+`ninst'replace cov`ncov'std=stdS if _n==3+`ninst'save table4, replace 